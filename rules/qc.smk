# We outsource the individual QC steps for clarity.
include: "qc-fastq.smk"
include: "qc-bam.smk"
include: "qc-vcf.smk"

# =================================================================================================
#     MultiQC
# =================================================================================================

# Unfortunately, in some cluster environments, multiqc does not work due to char encoding issues, see
# https://github.com/ewels/MultiQC/issues/484 ... If you run into this issue, try running it locally.
#
# We use the output touch files here only, in order to keep the snakemake log a bit cleaner.
# In the past, we used _all_ files of all QC tools directly as input here, which lead to the multiqc
# rule in the snakemake log be incredibly long. However, the multiqc wrapper that we are using uses
# the directories of these files anyway, so we can just start with these in the first place.
# That is, our `done` files are in the same dir as the actual QC files, so multiqc still finds them.
rule multiqc:
    input:
        # Fastq QC tools
        "qc/fastqc/fastqc.done",
        "trimmed/trimming-reports.done",

        # Mapping QC tools
        "qc/samtools-stats/samtools-stats.done",
        "qc/samtools-flagstat/samtools-flagstat.done",
        "qc/qualimap/qualimap.done",
        "qc/picard/collectmultiplemetrics.done",
        get_dedup_done() if config["settings"]["remove-duplicates"] else [],

        # VCF QC tools, if requested
        # We only need the stats.vchk file of bcftools stats, but request the pdf here as well,
        # so that the bctools internal plots get generated by the bcftools_stats_plot rule as well.
        "qc/bcftools-stats/stats.vchk" if config["settings"]["bcftools-stats"] else [],
        "qc/bcftools-stats/summary.pdf" if config["settings"]["bcftools-stats"] else [],

        # Annotations, if requested
        "annotated/snpeff.csv" if config["settings"]["snpeff"] else [],
        "annotated/vep_summary.html" if config["settings"]["vep"] else [],

        # Damage profiling, if requested
        "mapdamage/mapdamage.done" if config["settings"]["mapdamage"] else [],
        "damageprofiler/damageprofiler.done" if config["settings"]["damageprofiler"] else []

    output:
        report("qc/multiqc.html", caption="../reports/multiqc.rst", category="Quality control")
    params:
        config["params"]["multiqc"]["extra"],
    log:
        "logs/multiqc.log"
    conda:
        # We use a conda environment on top of the wrapper, as the wrapper always causes
        # issues with missing python modules and mismatching program versions and stuff...
        "../envs/multiqc.yaml"
    wrapper:
        "0.74.0/bio/multiqc"
    # script:
    #     # We use our own version of the wrapper here, to troubleshoot dependecy issues...
    #     "../scripts/multiqc.py"

# Rule is not submitted as a job to the cluster.
# Edit: It is now, as it turns out to be quite the process for large datasets...
# localrules: multiqc

# =================================================================================================
#     All QC, but not SNP calling
# =================================================================================================

# This alternative target rule executes all quality control (QC) steps of read trimming and mapping,
# but does not call SNPs, and does not call snpeff. The result is mainly the MultiQC report (without
# the snpeff part however), as well as the fastqc reports.
rule all_qc:
    input:
        # Quality control
        "qc/multiqc.html",

        # Reference genome statistics, provided in the prep steps
        config["data"]["reference-genome"] + ".seqkit"

# The `all_qc` rule is local. It does not do anything anyway,
# except requesting the other rules to run.
localrules: all_qc
